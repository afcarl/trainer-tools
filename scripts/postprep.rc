pssh -I tee /tmp/postprep.py <<EOF
#!/usr/bin/env python

#################################

COMPOSE_VERSION = "1.6.2"
MACHINE_VERSION = "0.6.0"
SWARM_VERSION = "1.1.3-rc1"

#################################

# This script will be run as ubuntu user.
# it's fine until we get to docker ps or whatever, we'll have to use sudo because the ubuntu user has no access to the docker socket.

import os
import sys
import urllib

STEP = 0

def bold(msg):
    return "{} {} {}".format("$(tput smso)", msg, "$(tput rmso)")

def system(cmd):
    global STEP
    # can also use subprocess.check_call
    # but have to pass an extra flag to do shell processing
    with open("/tmp/pp.status", "a") as f:
        f.write(bold("--- RUNNING [step {}] ---> {}...".format(STEP, cmd)))
        retcode = os.system(cmd)
        if retcode:
            retcode = bold(retcode)
        f.write("[{}]\n".format(retcode))
        STEP += 1
    with open(".bash_history", "a") as f:
        f.write("{}\n".format(cmd))

def test_system():
    commands = [
        "hostname",
        "sudo ls -la /mnt/docker",
        "which fig",
        "sudo docker version",
        "sudo curl --silent localhost:55555",
        "sudo docker images",
        "sudo docker ps",
    ]
    with open("/tmp/pp.status", "a") as f:
        for cmd in commands:
            retcode = os.system(cmd)
            f.write("  ** [{}] --> {}\n".format(cmd, retcode))
        
def ip_to_hostname():
    pass

### BEGIN CLOUDINIT
print("Welcome to postprep.rc!")
begin=os.system("date")

# On EC2, the ephemeral disk might be mounted on /mnt.
# If /mnt is a mountpoint, place Docker workspace on it.
system("if mountpoint -q /mnt; then sudo mkdir /mnt/docker && sudo ln -s /mnt/docker /var/lib/docker; fi")

### HOSTNAME FUCKERY ###
# Set the hostname to be the public IP address of the instance, with '-' instead of '.'.
# put our public IP and hostname in temporary files
system("curl --silent http://169.254.169.254/latest/meta-data/public-ipv4 > /tmp/ipv4")
#system("curl --silent http://169.254.169.254/latest/meta-data/public-ipv4 | tr '.' '-' > /tmp/hostname")

ipv4 = open("/tmp/ipv4").read()
#hostname = open("/tmp/hostname").read()

#with open("/tmp/etc-hosts-entry", "w") as f:
#    f.write("{} localhost".format(hostname))

#system("cat /tmp/etc-hosts-entry | sudo tee -a /etc/hosts")
#system("sudo hostnamectl set-hostname {}".format(hostname))

# system("curl --silent http://169.254.169.254/latest/meta-data/public-ipv4 | tr '.' '-' | xargs sudo hostnamectl set-hostname")

#        hostname_localhost = ipaddr.replace('.', '-') + " localhost"
#        os.system("grep ^{} /etc/hosts || echo {} | sudo tee -a /etc/hosts"
#                    .format(hostname_localhost, hostname_localhost))
#########################

# Add a docker user with password "training"
system("sudo useradd -d /home/docker -m -s /bin/bash docker")
system("echo docker:training | sudo chpasswd")

# Fancy prompt courtesy of @soulshake.
#system("echo \"export PS1='\e[1m\[\033[0;35m\]\u@{}\[\033[0;33m\] \w\[\033[00m\]: '\" >> .bashrc".format(ipv4))
system("echo \"export PS1='\e[1m\[\033[0;35m\]\u@{}\[\033[0;33m\] \w\[\033[00m\]\n$ '\" | sudo tee -a /home/docker/.bashrc".format(ipv4))
system("echo \"export PS1='\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]\n$ '\" | sudo tee -a /etc/skel/.bashrc")

# Copy authorized keys to /home/docker/.ssh/
#os.system("sudo mkdir -p /home/docker/.ssh")
#os.system("sudo cp /home/ubuntu/.ssh/authorized_keys /home/docker/.ssh/authorized_keys")
#os.system("sudo chown docker /home/docker/.ssh")
#os.system("sudo chown docker /home/docker/.ssh/authorized_keys")

# add docker user to sudoers and allow password authentication
system("sudo bash -c \"echo 'docker ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/docker\"")
system("sudo sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config")

system("sudo service ssh restart")
system("sudo apt-get -q update")
system("sudo apt-get -qy install git jq python-pip")

# before switching to systemd, this is how you would change the parameters for the docker daemon
# he left it here because he heard we might want to homogenize stuff
#os.system("sudo apt-get remove -y --purge dnsmasq-base")
#os.system("sudo apt-get -qy install python-setuptools pssh apache2-utils httping htop unzip")
#os.system("sudo easy_install pip")

# increase the size of the conntrack table so we don't blow it up when going crazy with http load testing
os.system("echo 1000000 | sudo tee /proc/sys/net/nf_conntrack_max")


### DOCKER INSTALLS ###

# This will install the latest Docker.
system("curl --silent https://get.docker.com/ | grep -v '( set -x; sleep 20 )' | sudo sh")

# Make sure that the daemon listens on 55555 (for orchestration workshop).
# To test, run: export DOCKER_HOST=tcp://localhost:55555 ; docker ps
# or, run "curl localhost:55555" (it should return 404 not found). If it tells you connection refused, that's a bad sign
system("sudo sed -i 's,-H fd://$,-H fd:// -H tcp://0.0.0.0:55555,' /lib/systemd/system/docker.service")
system("sudo systemctl daemon-reload")

# There seems to be a bug in the systemd scripts; so work around it.
# See https://github.com/docker/docker/issues/18444
# if docker is already running, need to do a restart
system("curl --silent localhost:55555 || sudo systemctl restart docker ")  # does this work? if not, next line should cover it
system("sudo systemctl start docker || true")

### Install docker-compose
# we'll use pip because interrupt signals are broken in the single binary version of 1.6.whatever-rc
system("sudo pip install -U docker-compose=={}".format(COMPOSE_VERSION))
#os.system("sudo pip uninstall -y docker-compose")
#os.system("sudo curl -sSL -o /usr/local/bin/docker-compose https://github.com/docker/compose/releases/download/{}/docker-compose-$(uname -s)-$(uname -m)".format(COMPOSE_VERSION))
#os.system("sudo chmod +x /usr/local/bin/docker-compose")

# Link so that older versions of the training still work properly
system("sudo ln -sf /usr/local/bin/docker-compose /usr/local/bin/fig")

### Install docker-machine
# docker-machine used to have a single binary, then they switched to multiple binaries for plugins, so it was distributed as a zip.
# Then it went back to single. Keeping commented references below just in case.
## os.system("sudo curl -sSL https://github.com/docker/machine/releases/download/v{}/docker-machine_linux-amd64.zip -o /tmp/docker-machine.zip".format(MACHINE_VERSION))
## os.system("cd /usr/local/bin ; sudo unzip /tmp/docker-machine.zip")
os.system("sudo curl -sSL -o /usr/local/bin/docker-machine https://github.com/docker/machine/releases/download/v{}/docker-machine-$(uname -s)-$(uname -m)".format(MACHINE_VERSION))
os.system("sudo chmod +x /usr/local/bin/docker-machine*")

# Wait for docker to be up.
# If we don't do this, Docker will not be responsive during the next step.
system("while ! sudo docker version ; do sleep 2; done")

### Install Swarm
os.system("docker pull swarm:{}".format(SWARM_VERSION))
os.system("docker tag -f swarm:{} swarm".format(SWARM_VERSION))

# Pre-pull a bunch of images
for I in [
    "debian:latest",
    "ubuntu:latest",
    "fedora:latest",
    "centos:latest",
    "postgres",
    "redis",
    "training/namer",
    "nathanleclaire/redisonrails"
    ]:
    system("sudo docker pull {}".format(I))

system("echo 'end of cloudinit section of postprep.rc'")

test_system()

system("echo 'tests complete.'")
system("cat /tmp/pp.status")

### END CLOUDINIT

### BEGIN CLUSTERING ###

clustersize = 5

myaddr = urllib.urlopen("http://169.254.169.254/latest/meta-data/public-ipv4").read()
#myaddr = urllib.urlopen("http://myip.enix.org/REMOTE_ADDR").read()

addresses = list(l.strip() for l in sys.stdin)

def makenames(addrs):
    return [ "node%s"%(i+1) for i in range(len(addrs)) ]

keys = {}
while addresses:
    
    print(addresses)
    cluster = addresses[:clustersize]
    addresses = addresses[clustersize:]
    if myaddr not in cluster:
        continue
    names = makenames(cluster)
    for ipaddr, name in zip(cluster, names):
        os.system("grep ^{} /etc/hosts || echo {} {} | sudo tee -a /etc/hosts"
                    .format(ipaddr, ipaddr, name))
    if myaddr == cluster[0]:
        # If I'm node1 and don't have a private key, generate one (with empty passphrase)
        os.system("[ -f /home/docker/.ssh/id_rsa ] || ssh-keygen -t rsa -f /home/docker/.ssh/id_rsa -P ''")
        keys[cluster[0]] = open("/home/docker/.ssh/id_rsa.pub").read()
    else:
        if cluster[0] in keys:
            system("cat {} | sudo tee -a /home/docker/authorized_keys".format(keys[cluster[0]]))
        else:
            print(cluster)
            print(keys)
            print(myaddr)
            print(addresses)
            raise


end = os.system("date")
system("echo '{}' && echo '{}'".format(begin, end))
EOF
# First, the ssh-keygen needs to happen as the "docker" user
# But that part is pretty easy, it just has to be wrapped with sudo and it should work then
# i.e. [ if I'm node1 ] && sudo -u docker ssh-keygen -t rsa blablabla
# then...  SUDO ALL THE THINGS, i.e.
#  sudo -u docker [ /home/docker/.ssh/id_rsa ] || sudo -u docker scp node1:.ssh/id_rsa /home/docker/.ssh/id_rsa
# then you test that by pssh'ing into a 5 node cluster to see what happens
# and when you test, you pass -i to pssh so you can see the output

pssh --timeout 600 --send-input "python /tmp/postprep.py >>/tmp/pp.out 2>>/tmp/pp.err" < ips.txt

echo "If /home/docker/.ssh/id_rsa doesn't exist, copy it from node1." | tee -a /tmp/pp.status
pssh "[ -f /home/docker/.ssh/id_rsa ] || scp -o StrictHostKeyChecking=no node1:/home/docker/.ssh/id_rsa* /home/docker/.ssh"

# if 'docker@' doesn't appear in /home/docker/.ssh/authorized_keys, copy it there
pssh "grep docker@ /home/docker/.ssh/authorized_keys || cat /home/docker/.ssh/id_rsa.pub sudo tee -a /home/docker/.ssh/authorized_keys"

