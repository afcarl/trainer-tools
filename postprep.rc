pssh -I tee /tmp/postprep.py <<EOF
#!/usr/bin/env python
# this will be run as ubuntu user
# it's fine until we get to docker ps or whatever, we'll have to use sudo because the ubuntu user has no access to the docker socket
import os
import sys
import urllib

def update_status(msg):
    #os.system("echo $PID '{}' >> /tmp/pp.status".format(msg))
    os.system("echo '{}'".format(msg))

### BEGIN CLOUDINIT

# On EC2, the ephemeral disk might be mounted on /mnt.
# If /mnt is a mountpoint, place Docker workspace on it.
update_status("linking /mnt/docker to /var/lib/docker")
os.system("if mountpoint -q /mnt; then sudo mkdir /mnt/docker && sudo ln -s /mnt/docker /var/lib/docker; fi")

# Set the hostname to be the public IP address of the instance.
# If the call to myip fails, set a default hostname.
#update_status("assigning our IP as our hostname")
#os.system("if ! curl --silent --fail http://myip.enix.org/REMOTE_ADDR | sudo tee /etc/hostname; then echo dockerhost | sudo tee /etc/hostname; fi")
#os.system("sudo hostname $(cat /etc/hostname)")
#os.system("sudo service hostname start")

# Fancy prompt courtesy of @soulshake.
ps1 = '\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]: '
os.system("echo 'export PS1={}\' | sudo tee -a /etc/skel/.bashrc".format(ps1))

update_status("adding docker user")
os.system("sudo useradd -d /home/docker -m -s /bin/bash docker")

update_status("adding password 'training' for 'docker' user")
os.system("echo docker:training | sudo chpasswd")

#update_status("copying authorized keys to /home/docker/.ssh/")
#os.system("sudo mkdir -p /home/docker/.ssh")
#os.system("sudo cp /home/ubuntu/.ssh/authorized_keys /home/docker/.ssh/authorized_keys")

update_status("adding docker user to sudoers")
os.system("sudo bash -c \"echo 'docker ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/docker\"")

update_status("allowing password authentication")
os.system("sudo sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config")

update_status("restarting ssh")
os.system("sudo service ssh restart")

update_status("apt-get updating")
os.system("sudo apt-get -q update")

update_status("installing git jq python-pip")
os.system("sudo apt-get -qy install git jq python-pip")

update_status("installing docker")
# This will install the latest Docker.
os.system("curl https://get.docker.com/ | grep -v '( set -x; sleep 20 )' | sudo sh")

# Make sure that the daemon listens on 55555 (for orchestration workshop).
os.system("sudo sed -i 's,-H fd://$,-H fd:// -H tcp://0.0.0.0:55555,' /lib/systemd/system/docker.service")
os.system("sudo systemctl daemon-reload")

update_status("starting docker")
# There seems to be a bug in the systemd scripts; so work around it.
# See https://github.com/docker/docker/issues/18444
os.system("sudo systemctl start docker || true")

update_status("pip-installing docker-compose")
os.system("sudo pip install -U docker-compose")

# Link so that older versions of the training still work properly
update_status("linking fig -> docker-compose")
os.system("sudo ln -sf /usr/local/bin/docker-compose /usr/local/bin/fig")

# Wait for docker to be up.
# If we don't do this, Docker will not be responsive during the next step.
update_status("waiting for docker to be installed")
os.system("while ! sudo docker version ; do sleep 1; done")

update_status("pulling images")
for I in [
    "debian:latest",
    "ubuntu:latest",
    "fedora:latest",
    "centos:latest",
    "postgres",
    "redis",
    "training/namer",
    "nathanleclaire/redisonrails"
    ]:
    os.system("sudo docker pull {}".format(I))

update_status("end of cloudinit section of postprep")

### END CLOUDINIT

COMPOSE_VERSION = "1.6.2"
MACHINE_VERSION = "0.6.0"
SWARM_VERSION = "1.1.3-rc1"

clustersize = 5

myaddr = urllib.urlopen("http://myip.enix.org/REMOTE_ADDR").read()

addresses = list(l.strip() for l in sys.stdin)

def makenames(addrs):
    return [ "node%s"%(i+1) for i in range(len(addrs)) ]

while addresses:
    print(addresses)
    cluster = addresses[:clustersize]
    addresses = addresses[clustersize:]
    if myaddr not in cluster:
        continue
    names = makenames(cluster)
    for ipaddr, name in zip(cluster, names):
        os.system("grep ^%s /etc/hosts || echo %s %s | sudo tee -a /etc/hosts"
                  %(ipaddr, ipaddr, name))
    if myaddr == cluster[0]:
        os.system("[ -f .ssh/id_rsa ] || ssh-keygen -t rsa -f .ssh/id_rsa -P ''")

#os.system("sudo apt-get remove -y --purge dnsmasq-base")
#os.system("sudo apt-get -qy install python-setuptools pssh apache2-utils httping htop unzip")
#os.system("sudo easy_install pip")
#os.system("sudo pip uninstall -y docker-compose")
##os.system("sudo pip install docker-compose=={}".format(COMPOSE_VERSION))
#os.system("sudo curl -sSL -o /usr/local/bin/docker-compose https://github.com/docker/compose/releases/download/{}/docker-compose-$(uname -s)-$(uname -m)".format(COMPOSE_VERSION))
#os.system("sudo chmod +x /usr/local/bin/docker-compose")
#os.system("docker pull swarm:{}".format(SWARM_VERSION))
#os.system("docker tag -f swarm:{} swarm".format(SWARM_VERSION))
##os.system("sudo curl -sSL https://github.com/docker/machine/releases/download/v{}/docker-machine_linux-amd64.zip -o /tmp/docker-machine.zip".format(MACHINE_VERSION))
##os.system("cd /usr/local/bin ; sudo unzip /tmp/docker-machine.zip")
#os.system("sudo curl -sSL -o /usr/local/bin/docker-machine https://github.com/docker/machine/releases/download/v{}/docker-machine-$(uname -s)-$(uname -m)".format(MACHINE_VERSION))
#os.system("sudo chmod +x /usr/local/bin/docker-machine*")
#os.system("echo 1000000 | sudo tee /proc/sys/net/nf_conntrack_max")
##os.system("""sudo sed -i 's,^DOCKER_OPTS=.*,DOCKER_OPTS="-H unix:///var/run/docker.sock -H tcp://0.0.0.0:55555",' /etc/default/docker""")
##os.system("sudo service docker restart")
EOF

echo "feeding ips.txt to postprey.py" | tee -a /tmp/pp.status
pssh -t 300 -I "python /tmp/postprep.py >>/tmp/pp.out 2>>/tmp/pp.err" < ips.txt

echo "if .ssh/id_rsa doesn't exist, scp-ing stuff" | tee -a /tmp/pp.status
pssh "[ -f .ssh/id_rsa ] || scp -o StrictHostKeyChecking=no node1:.ssh/id_rsa* .ssh"

echo "grepping for docker@ in .ssh/authorized_keys" | tee -a /tmp/pp.status
pssh "grep docker@ .ssh/authorized_keys || cat .ssh/id_rsa.pub >> .ssh/authorized_keys"

