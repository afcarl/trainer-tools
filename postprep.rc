pssh -I tee /tmp/postprep.py <<EOF
#!/usr/bin/env python

#################################

COMPOSE_VERSION = "1.6.2"
MACHINE_VERSION = "0.6.0"
SWARM_VERSION = "1.1.3-rc1"

#################################

# This script will be run as ubuntu user.
# it's fine until we get to docker ps or whatever, we'll have to use sudo because the ubuntu user has no access to the docker socket.

import os
import sys
import urllib

STEP = 0

def bold(msg):
    return "{} {} {}".format("$(tput smso)", msg, "$(tput rmso)")

def system(cmd):
    global STEP
    # can also use subprocess.check_call
    # but have to pass an extra flag to do shell processing
    with open("/tmp/pp.status", "a") as f:
        f.write(bold("--- RUNNING [step {}] ---> {}...".format(STEP, cmd)))
        retcode = os.system(cmd)
        if retcode:
            retcode = bold(retcode)
        f.write("[{}]\n".format(retcode))
        STEP += 1

def test_system():
    commands = [
        "hostname",
        "sudo ls -la /mnt/docker",
        "which fig",
        "sudo docker version",
        "sudo curl --silent localhost:55555",
        "sudo docker images",
        "sudo docker ps",
    ]
    with open("/tmp/pp.status", "a") as f:
        for cmd in commands:
            retcode = os.system(cmd)
            f.write("  ** [{}] --> {}\n".format(cmd, retcode))
        

### BEGIN CLOUDINIT
print("Welcome to postprep.rc!")
begin=os.system("date")

# Fancy prompt courtesy of @soulshake.
system("sudo chmod 666 /etc/skel/.bashrc")
system("echo \"export PS1='\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]: '\" >> .bashrc")
system("sudo chmod 666 /home/docker/.bashrc")
system("echo \"export PS1='\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]\n$ '\" >> /home/docker/.bashrc")
system("sudo echo \"export PS1='\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]\n$ '\" >> /etc/skel/.bashrc")
# ps1 = '\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]: '
# system("sudo echo \"PS1={}\" >> /etc/skel/.bashrc".format(ps1))
# ps1 = '\e[1m\[\033[0;35m\]\u@`hostname -i`\[\033[0;33m\] \w\[\033[00m\]: '
# system("echo 'export PS1={}\' | sudo tee -a /etc/skel/.bashrc".format(ps1))

# On EC2, the ephemeral disk might be mounted on /mnt.
# If /mnt is a mountpoint, place Docker workspace on it.
system("if mountpoint -q /mnt; then sudo mkdir /mnt/docker && sudo ln -s /mnt/docker /var/lib/docker; fi")

# Set the hostname to be the public IP address of the instance.
# If the call to myip fails, set a default hostname.
# Actually, don't. Use the default hostname (ip-172-123-123-123)

# Add a docker user with password "training"
system("sudo useradd -d /home/docker -m -s /bin/bash docker")
system("echo docker:training | sudo chpasswd")

# Copy authorized keys to /home/docker/.ssh/
os.system("sudo mkdir -p /home/docker/.ssh")
os.system("sudo cp /home/ubuntu/.ssh/authorized_keys /home/docker/.ssh/authorized_keys")
os.system("sudo chown docker /home/docker/.ssh/authorized_keys")

# add docker user to sudoers and allow password authentication
system("sudo bash -c \"echo 'docker ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/docker\"")
system("sudo sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config")

system("sudo service ssh restart")
system("sudo apt-get -q update")
system("sudo apt-get -qy install git jq python-pip")

# before switching to systemd, this is how you would change the parameters for the docker daemon
# he left it here because he heard we might want to homogenize stuff
#os.system("sudo apt-get remove -y --purge dnsmasq-base")
#os.system("sudo apt-get -qy install python-setuptools pssh apache2-utils httping htop unzip")
#os.system("sudo easy_install pip")

# increase the size of the conntrack table so we don't blow it up when going crazy with http load testing
os.system("echo 1000000 | sudo tee /proc/sys/net/nf_conntrack_max")


### DOCKER INSTALLS ###

# This will install the latest Docker.
system("curl --silent https://get.docker.com/ | grep -v '( set -x; sleep 20 )' | sudo sh")

# Make sure that the daemon listens on 55555 (for orchestration workshop).
# To test, run: export DOCKER_HOST=tcp://localhost:55555 ; docker ps
# or, run "curl localhost:55555" (it should return 404 not found). If it tells you connection refused, that's a bad sign
system("sudo sed -i 's,-H fd://$,-H fd:// -H tcp://0.0.0.0:55555,' /lib/systemd/system/docker.service")
system("sudo systemctl daemon-reload")

# There seems to be a bug in the systemd scripts; so work around it.
# See https://github.com/docker/docker/issues/18444
# if docker is already running, need to do a restart
system("curl --silent localhost:55555 || sudo systemctl restart docker ")  # does this work? if not, next line should cover it
system("sudo systemctl start docker || true")

### Install docker-compose
# we'll use pip because interrupt signals are broken in the single binary version of 1.6.whatever-rc
system("sudo pip install -U docker-compose=={}".format(COMPOSE_VERSION))
#os.system("sudo pip uninstall -y docker-compose")
#os.system("sudo curl -sSL -o /usr/local/bin/docker-compose https://github.com/docker/compose/releases/download/{}/docker-compose-$(uname -s)-$(uname -m)".format(COMPOSE_VERSION))
#os.system("sudo chmod +x /usr/local/bin/docker-compose")

# Link so that older versions of the training still work properly
system("sudo ln -sf /usr/local/bin/docker-compose /usr/local/bin/fig")

### Install docker-machine
# docker-machine used to have a single binary, then they switched to multiple binaries for plugins, so it was distributed as a zip.
# Then it went back to single. Keeping commented references below just in case.
## os.system("sudo curl -sSL https://github.com/docker/machine/releases/download/v{}/docker-machine_linux-amd64.zip -o /tmp/docker-machine.zip".format(MACHINE_VERSION))
## os.system("cd /usr/local/bin ; sudo unzip /tmp/docker-machine.zip")
os.system("sudo curl -sSL -o /usr/local/bin/docker-machine https://github.com/docker/machine/releases/download/v{}/docker-machine-$(uname -s)-$(uname -m)".format(MACHINE_VERSION))
os.system("sudo chmod +x /usr/local/bin/docker-machine*")

# Wait for docker to be up.
# If we don't do this, Docker will not be responsive during the next step.
system("while ! sudo docker version ; do sleep 2; done")

### Install Swarm
os.system("docker pull swarm:{}".format(SWARM_VERSION))
os.system("docker tag -f swarm:{} swarm".format(SWARM_VERSION))

# Pre-pull a bunch of images
for I in [
    "debian:latest",
    "ubuntu:latest",
    "fedora:latest",
    "centos:latest",
    "postgres",
    "redis",
    "training/namer",
    "nathanleclaire/redisonrails"
    ]:
    system("sudo docker pull {}".format(I))

system("echo 'end of cloudinit section of postprep.rc'")

test_system()

system("echo 'tests complete.'")
system("cat /tmp/pp.status")

### END CLOUDINIT

### BEGIN CLUSTERING ###

clustersize = 5

myaddr = urllib.urlopen("http://myip.enix.org/REMOTE_ADDR").read()

addresses = list(l.strip() for l in sys.stdin)

def makenames(addrs):
    return [ "node%s"%(i+1) for i in range(len(addrs)) ]

while addresses:
    print(addresses)
    cluster = addresses[:clustersize]
    addresses = addresses[clustersize:]
    if myaddr not in cluster:
        continue
    names = makenames(cluster)
    for ipaddr, name in zip(cluster, names):
        os.system("grep ^%s /etc/hosts || echo %s %s | sudo tee -a /etc/hosts"
                  %(ipaddr, ipaddr, name))
    if myaddr == cluster[0]:
        os.system("[ -f .ssh/id_rsa ] || ssh-keygen -t rsa -f .ssh/id_rsa -P ''")

end = os.system("date")
system("echo '{}' && echo '{}'".format(begin, end))
EOF

echo "Executing postprep.py..."
pssh --timeout 300 --send-input "python /tmp/postprep.py >>/tmp/pp.out 2>>/tmp/pp.err" < ips.txt
retcode=$(echo $?)
echo $retcode
if [ $retcode -ne 0 ]; then
    echo "Execution of postprep.py failed; exit code was $retcode"
    ssh ubuntu@$(tail -1 ips.txt) "cat /tmp/pp.out"
fi

echo "Disabling StrictHostKeyChecking on node1." | tee -a /tmp/pp.status
pssh "[ -f .ssh/id_rsa ] || scp -o StrictHostKeyChecking=no node1:.ssh/id_rsa* .ssh"

echo "grepping for docker@ in .ssh/authorized_keys" | tee -a /tmp/pp.status
pssh "grep docker@ .ssh/authorized_keys || cat .ssh/id_rsa.pub >> .ssh/authorized_keys"
